{"version":3,"file":"index.modern.mjs","sources":["../src/queryClientAtom.ts","../src/utils.ts","../src/baseAtomWithQuery.ts","../src/atomWithQuery.ts","../src/atomWithSuspenseQuery.ts","../src/atomWithInfiniteQuery.ts","../src/atomWithMutation.ts","../src/atomWithSuspenseInfiniteQuery.ts","../src/atomWithMutationState.ts"],"sourcesContent":["import { QueryClient } from '@tanstack/query-core'\nimport { atom } from 'jotai/vanilla'\n\nexport const queryClientAtom = atom(new QueryClient())\n\nif (process.env.NODE_ENV !== 'production') {\n  queryClientAtom.debugPrivate = true\n}\n","import type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean\n) => result.isPending && !isRestoring\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  throwOnError,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  throwOnError:\n    | ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n    | undefined\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !result.isFetching &&\n    shouldThrowError(throwOnError, [result.error, query])\n  )\n}\n\nexport function shouldThrowError<T extends (...args: any[]) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n","import {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  DefaultedQueryObserverOptions,\n  InfiniteQueryObserver,\n  InfiniteQueryObserverResult,\n  InfiniteQueryObserverSuccessResult,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n  QueryObserverSuccessResult,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { make, pipe, toObservable } from 'wonka'\nimport { queryClientAtom } from './queryClientAtom'\nimport { getHasError, shouldSuspend } from './utils'\n\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > & { suspense: true; enabled: true },\n  getObserver: (\n    get: Getter\n  ) => QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<Promise<QueryObserverSuccessResult<TData, TError>>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > & { suspense: false },\n  getObserver: (\n    get: Getter\n  ) => QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<QueryObserverResult<TData, TError>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  > & { suspense: true; enabled: true },\n  getObserver: (\n    get: Getter\n  ) => InfiniteQueryObserver<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<Promise<InfiniteQueryObserverSuccessResult<TData, TError>>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  > & { suspense: false },\n  getObserver: (\n    get: Getter\n  ) => InfiniteQueryObserver<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<InfiniteQueryObserverResult<TData, TError>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  getObserver: (\n    get: Getter\n  ) => QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n) {\n  const resetAtom = atom(0)\n  if (process.env.NODE_ENV !== 'production') {\n    resetAtom.debugPrivate = true\n  }\n\n  const observableAtom = atom((get) => {\n    const observer = getObserver(get)\n    const source = make<QueryObserverResult<TData, TError>>(({ next }) => {\n      const callback = (result: QueryObserverResult<TData, TError>) => {\n        next(result)\n      }\n\n      return observer.subscribe(callback)\n    })\n    return pipe(source, toObservable)\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observableAtom.debugPrivate = true\n  }\n\n  const dataAtom = atom((get) => {\n    const observer = getObserver(get)\n    const observable = get(observableAtom)\n\n    const currentResult = observer.getCurrentResult()\n    const resultAtom = atom(currentResult)\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    resultAtom.onMount = (set) => {\n      const { unsubscribe } = observable.subscribe((state) => {\n        set(state)\n      })\n      return () => unsubscribe()\n    }\n\n    return resultAtom\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    dataAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    const observer = getObserver(get)\n    const options = getOptions(get)\n\n    const client = getQueryClient(get)\n\n    resetAtom.onMount = () => {\n      return () => {\n        if (observer.getCurrentResult().isError) {\n          client.resetQueries({ queryKey: observer.getCurrentQuery().queryKey })\n        }\n      }\n    }\n\n    get(resetAtom)\n    get(get(dataAtom))\n\n    const result = observer.getOptimisticResult(options)\n\n    if (shouldSuspend(options, result, false)) {\n      return observer.fetchOptimistic(options)\n    }\n\n    if (\n      getHasError({\n        result,\n        query: observer.getCurrentQuery(),\n        throwOnError: options.throwOnError,\n      })\n    ) {\n      throw result.error\n    }\n\n    return result\n  })\n}\n","import {\n  DefaultError,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport function atomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => Omit<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n    'suspense'\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<QueryObserverResult<TData, TError>> {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(options)\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new QueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  return baseAtomWithQuery<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n    (get) => ({ ...get(optionsAtom), suspense: false }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n","import {\n  DefaultError,\n  type DefinedQueryObserverResult,\n  QueryClient,\n  type QueryKey,\n  QueryObserver,\n  type QueryObserverOptions,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport const atomWithSuspenseQuery = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => Omit<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n    'suspense' | 'enabled'\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<\n  | DefinedQueryObserverResult<TData, TError>\n  | Promise<DefinedQueryObserverResult<TData, TError>>\n> => {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(options)\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (typeof dOptions.staleTime !== 'number') {\n      dOptions.staleTime = 1000\n    }\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new QueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  return baseAtomWithQuery<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n    (get) => ({\n      ...get(optionsAtom),\n      suspense: true,\n      enabled: true,\n    }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n","import { InfiniteQueryObserver, QueryClient } from '@tanstack/query-core'\nimport type {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  WithRequired,\n} from '@tanstack/query-core'\nimport { Atom, type Getter, atom } from 'jotai/vanilla'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport function atomWithInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => InfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<InfiniteQueryObserverResult<TData, TError>> {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        InfiniteQueryObserver<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryFnData,\n          TQueryKey,\n          TPageParam\n        >\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(\n      options\n    ) as DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new InfiniteQueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n\n  return baseAtomWithQuery<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >(\n    (get) => ({\n      ...get(optionsAtom),\n      suspense: false,\n    }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n\ninterface InfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends WithRequired<\n    Omit<\n      InfiniteQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey,\n        TPageParam\n      >,\n      'suspense'\n    >,\n    'queryKey'\n  > {}\n","import {\n  MutationObserver,\n  type MutationObserverOptions,\n  type MutationObserverResult,\n  QueryClient,\n} from '@tanstack/query-core'\nimport { Getter, atom } from 'jotai'\nimport { make, pipe, toObservable } from 'wonka'\nimport { queryClientAtom } from './queryClientAtom'\nimport { shouldThrowError } from './utils'\n\nexport function atomWithMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => MutationObserverOptions<TData, TError, TVariables, TContext>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n) {\n  const IN_RENDER = Symbol()\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    return client.defaultMutationOptions(options)\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        MutationObserver<TData, TError, TVariables, TContext>\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n    const observerCache = get(observerCacheAtom)\n\n    const observer = observerCache.get(client)\n\n    if (observer) {\n      ;(observer as any)[IN_RENDER] = true\n      observer.setOptions(options)\n      delete (observer as any)[IN_RENDER]\n\n      return observer\n    }\n\n    const newObserver = new MutationObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  const observableAtom = atom((get) => {\n    const observer = get(observerAtom)\n    const source = make<\n      MutationObserverResult<TData, TError, TVariables, TContext>\n    >(({ next }) => {\n      const callback = (\n        result: MutationObserverResult<TData, TError, TVariables, TContext>\n      ) => {\n        const notifyResult = () => next(result)\n\n        if ((observer as any)[IN_RENDER]) {\n          Promise.resolve().then(notifyResult)\n        } else {\n          notifyResult()\n        }\n      }\n\n      return observer.subscribe(callback)\n    })\n    return pipe(source, toObservable)\n  })\n\n  const dataAtom = atom((get) => {\n    const observer = get(observerAtom)\n    const observable = get(observableAtom)\n\n    const currentResult = observer.getCurrentResult()\n    const resultAtom = atom(currentResult)\n\n    resultAtom.onMount = (set) => {\n      const { unsubscribe } = observable.subscribe((state) => {\n        set(state)\n      })\n      return () => {\n        unsubscribe\n        observer.reset()\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  const mutateAtom = atom((get) => {\n    const observer = get(observerAtom)\n    const mutate = (\n      variables: TVariables,\n      options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n    ) => {\n      observer.mutate(variables, options).catch(noop)\n    }\n\n    return mutate\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    mutateAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    const observer = get(observerAtom)\n    const resultAtom = get(dataAtom)\n\n    const result = get(resultAtom)\n    const mutate = get(mutateAtom)\n\n    if (\n      result.isError &&\n      shouldThrowError(observer.options.throwOnError, [result.error])\n    ) {\n      throw result.error\n    }\n\n    return { ...result, mutate, mutateAsync: result.mutate }\n  })\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  InfiniteData,\n  InfiniteQueryObserver,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverSuccessResult,\n  QueryClient,\n  type QueryKey,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport const atomWithSuspenseInfiniteQuery = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => SuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TPageParam,\n    TData,\n    TQueryKey\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<Promise<InfiniteQueryObserverSuccessResult<TData, TError>>> => {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        InfiniteQueryObserver<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryFnData,\n          TQueryKey,\n          TPageParam\n        >\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(\n      options\n    ) as DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (typeof dOptions.staleTime !== 'number') {\n      dOptions.staleTime = 1000\n    }\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new InfiniteQueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  return baseAtomWithQuery<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >(\n    (get) => ({\n      ...get(optionsAtom),\n      suspense: true,\n      enabled: true,\n    }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n\ninterface SuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TPageParam = unknown,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Omit<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n    'enabled' | 'throwOnError' | 'placeholderData'\n  > {}\n","import {\n  DefaultError,\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\nimport { Getter, atom } from 'jotai'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>\n): Array<TResult> {\n  return mutationCache\n    .findAll({ ...options.filters, status: 'pending' })\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>\n            )\n          : mutation.state) as TResult\n    )\n}\n\nexport const atomWithMutationState = <TResult = MutationState>(\n  getOptions: (get: Getter) => MutationStateOptions<TResult>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n) => {\n  const resultsAtom = atom<TResult[]>([])\n  if (process.env.NODE_ENV !== 'production') {\n    resultsAtom.debugPrivate = true\n  }\n\n  const observableAtom = atom((get) => {\n    const queryClient = getQueryClient(get)\n\n    const mutationCache = queryClient.getMutationCache()\n    resultsAtom.onMount = (set) => {\n      mutationCache.subscribe(() => {\n        set(getResult(getQueryClient(get).getMutationCache(), getOptions(get)))\n      })\n    }\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observableAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    get(observableAtom)\n    return get(resultsAtom)\n  })\n}\n"],"names":["queryClientAtom","atom","QueryClient","process","env","NODE_ENV","debugPrivate","shouldSuspend","defaultedOptions","result","isRestoring","suspense","willFetch","isPending","getHasError","throwOnError","query","isError","isFetching","shouldThrowError","error","params","baseAtomWithQuery","getOptions","getObserver","getQueryClient","get","resetAtom","observableAtom","observer","source","make","next","subscribe","pipe","toObservable","dataAtom","observable","currentResult","getCurrentResult","resultAtom","onMount","set","unsubscribe","state","options","client","resetQueries","queryKey","getCurrentQuery","getOptimisticResult","fetchOptimistic","atomWithQuery","observerCacheAtom","WeakMap","optionsAtom","cachedObserver","dOptions","defaultQueryOptions","_optimisticResults","setOptions","listeners","observerAtom","observerCache","newObserver","QueryObserver","_extends","atomWithSuspenseQuery","staleTime","enabled","atomWithInfiniteQuery","InfiniteQueryObserver","atomWithMutation","IN_RENDER","Symbol","defaultMutationOptions","MutationObserver","notifyResult","Promise","resolve","then","reset","mutateAtom","mutate","variables","catch","noop","mutateAsync","atomWithSuspenseInfiniteQuery","atomWithMutationState","resultsAtom","mutationCache","getMutationCache","findAll","filters","status","map","mutation","select","getResult"],"mappings":"kPAGa,MAAAA,EAAkBC,EAAK,IAAIC,uOAEX,eAAzBC,QAAQC,IAAIC,WACdL,EAAgBM,cAAe,GCE1B,MAAMC,EAAgBA,CAC3BC,EAGAC,EACAC,KACGF,MAAAA,OAAAA,EAAAA,EAAkBG,WAAYC,EAAUH,EAAQC,GAExCE,EAAYA,CACvBH,EACAC,IACGD,EAAOI,YAAcH,EAEbI,EAAcA,EAOzBL,SACAM,eACAC,WASEP,EAAOQ,UACNR,EAAOS,YACRC,EAAiBJ,EAAc,CAACN,EAAOW,MAAOJ,IAIlC,SAAAG,EACdJ,EACAM,GAGA,MAA4B,mBAAjBN,EACFA,KAAgBM,KAGhBN,CACX,UCiEgBO,EAOdC,EASAC,EAGAC,EAAgDC,IAAQA,EAAI1B,KAE5D,MAAM2B,EAAY1B,EAAK,GACM,eAAzBE,QAAQC,IAAIC,WACdsB,EAAUrB,cAAe,GAG3B,MAAMsB,EAAiB3B,EAAMyB,IAC3B,MAAMG,EAAWL,EAAYE,GACvBI,EAASC,EAAyC,EAAGC,UAKlDH,EAASI,UAJExB,IAChBuB,EAAKvB,EAAM,IAKf,OAAOyB,EAAKJ,EAAQK,EAAY,GAEL,eAAzBhC,QAAQC,IAAIC,WACduB,EAAetB,cAAe,GAGhC,MAAM8B,EAAWnC,EAAMyB,IACrB,MAAMG,EAAWL,EAAYE,GACvBW,EAAaX,EAAIE,GAEjBU,EAAgBT,EAASU,mBACzBC,EAAavC,EAAKqC,GAYxB,MAX6B,eAAzBnC,QAAQC,IAAIC,WACdmC,EAAWlC,cAAe,GAG5BkC,EAAWC,QAAWC,IACpB,MAAMC,YAAEA,GAAgBN,EAAWJ,UAAWW,IAC5CF,EAAIE,EACN,GACA,MAAO,IAAMD,GAAW,EAGnBH,IAMT,MAJ6B,eAAzBrC,QAAQC,IAAIC,WACd+B,EAAS9B,cAAe,GAGnBL,EAAMyB,IACX,MAAMG,EAAWL,EAAYE,GACvBmB,EAAUtB,EAAWG,GAErBoB,EAASrB,EAAeC,GAE9BC,EAAUc,QAAU,IACX,KACDZ,EAASU,mBAAmBtB,SAC9B6B,EAAOC,aAAa,CAAEC,SAAUnB,EAASoB,kBAAkBD,UAC5D,EAILtB,EAAIC,GACJD,EAAIA,EAAIU,IAER,MAAM3B,EAASoB,EAASqB,oBAAoBL,GAE5C,GAAItC,EAAcsC,EAASpC,GAAQ,GACjC,OAAOoB,EAASsB,gBAAgBN,GAGlC,GACE/B,EAAY,CACVL,SACAO,MAAOa,EAASoB,kBAChBlC,aAAc8B,EAAQ9B,eAGxB,MAAMN,EAAOW,MAGf,OAAOX,GAEX,CC/MgB,SAAA2C,EAOd7B,EAMAE,EAAgDC,IAAQA,EAAI1B,KAE5D,MAAMqD,EAAoBpD,EACxB,IACE,IAAIqD,SAKqB,eAAzBnD,QAAQC,IAAIC,WACdgD,EAAkB/C,cAAe,GAGnC,MAAMiD,EAActD,EAAMyB,IACxB,MAAMoB,EAASrB,EAAeC,GACxBmB,EAAUtB,EAAWG,GAErB8B,EADQ9B,EAAI2B,GACW3B,IAAIoB,GAC3BW,EAAWX,EAAOY,oBAAoBb,GAQ5C,OANAY,EAASE,mBAAqB,aAE1BH,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,IAEoB,eAAzBtD,QAAQC,IAAIC,WACdkD,EAAYjD,cAAe,GAG7B,MAAMwD,EAAe7D,EAAMyB,IACzB,MAAMmB,EAAUnB,EAAI6B,GACdT,EAASrB,EAAeC,GAExBqC,EAAgBrC,EAAI2B,GAEpBG,EAAiBO,EAAcrC,IAAIoB,GAEzC,GAAIU,EAAgB,OAAOA,EAE3B,MAAMQ,EAAc,IAAIC,EAAcnB,EAAQD,GAG9C,OAFAkB,EAAcrB,IAAII,EAAQkB,GAEnBA,IAMT,MAJ6B,eAAzB7D,QAAQC,IAAIC,WACdyD,EAAaxD,cAAe,GAGvBgB,EACJI,GAAGwC,EAAWxC,CAAAA,EAAAA,EAAI6B,GAAY,CAAE5C,UAAU,IAC1Ce,GAAQA,EAAIoC,GACbrC,EAEJ,CCrEa,MAAA0C,EAAwBA,CAOnC5C,EAMAE,EAAgDC,IAAQA,EAAI1B,OAK5D,MAAMqD,EAAoBpD,EACxB,IACE,IAAIqD,SAKqB,eAAzBnD,QAAQC,IAAIC,WACdgD,EAAkB/C,cAAe,GAGnC,MAAMiD,EAActD,EAAMyB,IACxB,MAAMoB,EAASrB,EAAeC,GACxBmB,EAAUtB,EAAWG,GAErB8B,EADQ9B,EAAI2B,GACW3B,IAAIoB,GAC3BW,EAAWX,EAAOY,oBAAoBb,GAY5C,OAVAY,EAASE,mBAAqB,aAEI,iBAAvBF,EAASW,YAClBX,EAASW,UAAY,KAGnBZ,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,IAEoB,eAAzBtD,QAAQC,IAAIC,WACdkD,EAAYjD,cAAe,GAG7B,MAAMwD,EAAe7D,EAAMyB,IACzB,MAAMmB,EAAUnB,EAAI6B,GACdT,EAASrB,EAAeC,GAExBqC,EAAgBrC,EAAI2B,GAEpBG,EAAiBO,EAAcrC,IAAIoB,GAEzC,GAAIU,EAAgB,OAAOA,EAE3B,MAAMQ,EAAc,IAAIC,EAAcnB,EAAQD,GAG9C,OAFAkB,EAAcrB,IAAII,EAAQkB,GAEnBA,IAMT,MAJ6B,eAAzB7D,QAAQC,IAAIC,WACdyD,EAAaxD,cAAe,GAGvBgB,EACJI,GAAGwC,EAAA,CAAA,EACCxC,EAAI6B,GAAY,CACnB5C,UAAU,EACV0D,SAAS,IAEV3C,GAAQA,EAAIoC,GACbrC,EAAc,EC5EF,SAAA6C,EAOd/C,EAGAE,EAAgDC,IAAQA,EAAI1B,KAE5D,MAAMqD,EAAoBpD,EACxB,IACE,IAAIqD,SAYqB,eAAzBnD,QAAQC,IAAIC,WACdgD,EAAkB/C,cAAe,GAEnC,MAAMiD,EAActD,EAAMyB,IACxB,MAAMoB,EAASrB,EAAeC,GACxBmB,EAAUtB,EAAWG,GAErB8B,EADQ9B,EAAI2B,GACW3B,IAAIoB,GAC3BW,EAAWX,EAAOY,oBACtBb,GAgBF,OANAY,EAASE,mBAAqB,aAE1BH,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,IAEoB,eAAzBtD,QAAQC,IAAIC,WACdkD,EAAYjD,cAAe,GAE7B,MAAMwD,EAAe7D,EAAMyB,IACzB,MAAMmB,EAAUnB,EAAI6B,GACdT,EAASrB,EAAeC,GAExBqC,EAAgBrC,EAAI2B,GAEpBG,EAAiBO,EAAcrC,IAAIoB,GACzC,GAAIU,EAAgB,OAAOA,EAE3B,MAAMQ,EAAc,IAAIO,EAAsBzB,EAAQD,GAGtD,OAFAkB,EAAcrB,IAAII,EAAQkB,GAEnBA,IAGT,OAAO1C,EAQJI,GAAGwC,KACCxC,EAAI6B,GACP5C,CAAAA,UAAU,IAEXe,GAAQA,EAAIoC,GACbrC,EAEJ,CCzFgB,SAAA+C,EAMdjD,EAGAE,EAAgDC,IAAQA,EAAI1B,KAE5D,MAAMyE,EAAYC,SAEZnB,EAActD,EAAMyB,IACxB,MAAMoB,EAASrB,EAAeC,GACxBmB,EAAUtB,EAAWG,GAC3B,OAAOoB,EAAO6B,uBAAuB9B,EAAO,GAEjB,eAAzB1C,QAAQC,IAAIC,WACdkD,EAAYjD,cAAe,GAG7B,MAAM+C,EAAoBpD,EACxB,IACE,IAAIqD,SAKqB,eAAzBnD,QAAQC,IAAIC,WACdgD,EAAkB/C,cAAe,GAGnC,MAAMwD,EAAe7D,EAAMyB,IACzB,MAAMmB,EAAUnB,EAAI6B,GACdT,EAASrB,EAAeC,GACxBqC,EAAgBrC,EAAI2B,GAEpBxB,EAAWkC,EAAcrC,IAAIoB,GAEnC,GAAIjB,EAKF,OAJEA,EAAiB4C,IAAa,EAChC5C,EAAS+B,WAAWf,UACZhB,EAAiB4C,GAElB5C,EAGT,MAAMmC,EAAc,IAAIY,EAAiB9B,EAAQD,GAGjD,OAFAkB,EAAcrB,IAAII,EAAQkB,GAEnBA,IAEoB,eAAzB7D,QAAQC,IAAIC,WACdyD,EAAaxD,cAAe,GAG9B,MAAMsB,EAAiB3B,EAAMyB,IAC3B,MAAMG,EAAWH,EAAIoC,GACfhC,EAASC,EAEb,EAAGC,UAaIH,EAASI,UAXdxB,IAEA,MAAMoE,EAAeA,IAAM7C,EAAKvB,GAE3BoB,EAAiB4C,GACpBK,QAAQC,UAAUC,KAAKH,GAEvBA,GACD,IAKL,OAAO3C,EAAKJ,EAAQK,EAAY,GAG5BC,EAAWnC,EAAMyB,IACrB,MAAMG,EAAWH,EAAIoC,GACfzB,EAAaX,EAAIE,GAEjBU,EAAgBT,EAASU,mBACzBC,EAAavC,EAAKqC,GAexB,OAbAE,EAAWC,QAAWC,IACIL,EAAWJ,UAAWW,IAC5CF,EAAIE,EACN,GACO,KAELf,EAASoD,OAAK,GAGW,eAAzB9E,QAAQC,IAAIC,WACdmC,EAAWlC,cAAe,GAGrBkC,IAGH0C,EAAajF,EAAMyB,IACvB,MAAMG,EAAWH,EAAIoC,GAQrB,MAPeqB,CACbC,EACAvC,KAEAhB,EAASsD,OAAOC,EAAWvC,GAASwC,MAAMC,EAC5C,CAEOH,GAMT,MAJ6B,eAAzBhF,QAAQC,IAAIC,WACd6E,EAAW5E,cAAe,GAGrBL,EAAMyB,IACX,MAAMG,EAAWH,EAAIoC,GACftB,EAAad,EAAIU,GAEjB3B,EAASiB,EAAIc,GACb2C,EAASzD,EAAIwD,GAEnB,GACEzE,EAAOQ,SACPE,EAAiBU,EAASgB,QAAQ9B,aAAc,CAACN,EAAOW,QAExD,MAAMX,EAAOW,MAGf,OAAA8C,EAAA,CAAA,EAAYzD,EAAM,CAAE0E,SAAQI,YAAa9E,EAAO0E,QAAM,EAE1D,CAGA,SAASG,KCrII,MAAAE,EAAgCA,CAO3CjE,EASAE,EAAgDC,IAAQA,EAAI1B,OAE5D,MAAMqD,EAAoBpD,EACxB,IACE,IAAIqD,SAYqB,eAAzBnD,QAAQC,IAAIC,WACdgD,EAAkB/C,cAAe,GAGnC,MAAMiD,EAActD,EAAMyB,IACxB,MAAMoB,EAASrB,EAAeC,GACxBmB,EAAUtB,EAAWG,GAErB8B,EADQ9B,EAAI2B,GACW3B,IAAIoB,GAC3BW,EAAWX,EAAOY,oBACtBb,GAoBF,OAVAY,EAASE,mBAAqB,aAEI,iBAAvBF,EAASW,YAClBX,EAASW,UAAY,KAGnBZ,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,IAEoB,eAAzBtD,QAAQC,IAAIC,WACdkD,EAAYjD,cAAe,GAG7B,MAAMwD,EAAe7D,EAAMyB,IACzB,MAAMmB,EAAUnB,EAAI6B,GACdT,EAASrB,EAAeC,GAExBqC,EAAgBrC,EAAI2B,GAEpBG,EAAiBO,EAAcrC,IAAIoB,GAEzC,GAAIU,EAAgB,OAAOA,EAE3B,MAAMQ,EAAc,IAAIO,EAAsBzB,EAAQD,GAGtD,OAFAkB,EAAcrB,IAAII,EAAQkB,GAEnBA,IAMT,MAJ6B,eAAzB7D,QAAQC,IAAIC,WACdyD,EAAaxD,cAAe,GAGvBgB,EAQJI,GAAGwC,EAAA,CAAA,EACCxC,EAAI6B,GAAY,CACnB5C,UAAU,EACV0D,SAAS,IAEV3C,GAAQA,EAAIoC,GACbrC,EAAc,ECjFLgE,EAAwBA,CACnClE,EACAE,EAAgDC,IAAQA,EAAI1B,OAE5D,MAAM0F,EAAczF,EAAgB,IACP,eAAzBE,QAAQC,IAAIC,WACdqF,EAAYpF,cAAe,GAG7B,MAAMsB,EAAiB3B,EAAMyB,IAC3B,MAEMiE,EAFclE,EAAeC,GAEDkE,mBAClCF,EAAYjD,QAAWC,IACrBiD,EAAc1D,UAAU,KACtBS,EA/BR,SACEiD,EACA9C,GAEA,OAAO8C,EACJE,QAAO3B,EAAA,CAAA,EAAMrB,EAAQiD,SAASC,OAAQ,aACtCC,IACEC,GACEpD,EAAQqD,OACLrD,EAAQqD,OACND,GAEFA,EAASrD,MAErB,CAiBYuD,CAAU1E,EAAeC,GAAKkE,mBAAoBrE,EAAWG,MAClE,IAOL,MAJ6B,eAAzBvB,QAAQC,IAAIC,WACduB,EAAetB,cAAe,GAGzBL,EAAMyB,IACXA,EAAIE,GACGF,EAAIgE,IACZ"}