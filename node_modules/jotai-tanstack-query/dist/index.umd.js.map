{"version":3,"file":"index.umd.js","sources":["../src/queryClientAtom.ts","../src/utils.ts","../src/baseAtomWithQuery.ts","../src/atomWithMutation.ts","../src/atomWithInfiniteQuery.ts","../src/atomWithMutationState.ts","../src/atomWithQuery.ts","../src/atomWithSuspenseInfiniteQuery.ts","../src/atomWithSuspenseQuery.ts"],"sourcesContent":["import { QueryClient } from '@tanstack/query-core'\nimport { atom } from 'jotai/vanilla'\n\nexport const queryClientAtom = atom(new QueryClient())\n\nif (process.env.NODE_ENV !== 'production') {\n  queryClientAtom.debugPrivate = true\n}\n","import type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean\n) => result.isPending && !isRestoring\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  throwOnError,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  throwOnError:\n    | ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n    | undefined\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !result.isFetching &&\n    shouldThrowError(throwOnError, [result.error, query])\n  )\n}\n\nexport function shouldThrowError<T extends (...args: any[]) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n","import {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  DefaultedQueryObserverOptions,\n  InfiniteQueryObserver,\n  InfiniteQueryObserverResult,\n  InfiniteQueryObserverSuccessResult,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n  QueryObserverSuccessResult,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { make, pipe, toObservable } from 'wonka'\nimport { queryClientAtom } from './queryClientAtom'\nimport { getHasError, shouldSuspend } from './utils'\n\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > & { suspense: true; enabled: true },\n  getObserver: (\n    get: Getter\n  ) => QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<Promise<QueryObserverSuccessResult<TData, TError>>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > & { suspense: false },\n  getObserver: (\n    get: Getter\n  ) => QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<QueryObserverResult<TData, TError>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  > & { suspense: true; enabled: true },\n  getObserver: (\n    get: Getter\n  ) => InfiniteQueryObserver<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<Promise<InfiniteQueryObserverSuccessResult<TData, TError>>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  > & { suspense: false },\n  getObserver: (\n    get: Getter\n  ) => InfiniteQueryObserver<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  getQueryClient?: (get: Getter) => QueryClient\n): Atom<InfiniteQueryObserverResult<TData, TError>>\nexport function baseAtomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  getObserver: (\n    get: Getter\n  ) => QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n) {\n  const resetAtom = atom(0)\n  if (process.env.NODE_ENV !== 'production') {\n    resetAtom.debugPrivate = true\n  }\n\n  const observableAtom = atom((get) => {\n    const observer = getObserver(get)\n    const source = make<QueryObserverResult<TData, TError>>(({ next }) => {\n      const callback = (result: QueryObserverResult<TData, TError>) => {\n        next(result)\n      }\n\n      return observer.subscribe(callback)\n    })\n    return pipe(source, toObservable)\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observableAtom.debugPrivate = true\n  }\n\n  const dataAtom = atom((get) => {\n    const observer = getObserver(get)\n    const observable = get(observableAtom)\n\n    const currentResult = observer.getCurrentResult()\n    const resultAtom = atom(currentResult)\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    resultAtom.onMount = (set) => {\n      const { unsubscribe } = observable.subscribe((state) => {\n        set(state)\n      })\n      return () => unsubscribe()\n    }\n\n    return resultAtom\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    dataAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    const observer = getObserver(get)\n    const options = getOptions(get)\n\n    const client = getQueryClient(get)\n\n    resetAtom.onMount = () => {\n      return () => {\n        if (observer.getCurrentResult().isError) {\n          client.resetQueries({ queryKey: observer.getCurrentQuery().queryKey })\n        }\n      }\n    }\n\n    get(resetAtom)\n    get(get(dataAtom))\n\n    const result = observer.getOptimisticResult(options)\n\n    if (shouldSuspend(options, result, false)) {\n      return observer.fetchOptimistic(options)\n    }\n\n    if (\n      getHasError({\n        result,\n        query: observer.getCurrentQuery(),\n        throwOnError: options.throwOnError,\n      })\n    ) {\n      throw result.error\n    }\n\n    return result\n  })\n}\n","import {\n  MutationObserver,\n  type MutationObserverOptions,\n  type MutationObserverResult,\n  QueryClient,\n} from '@tanstack/query-core'\nimport { Getter, atom } from 'jotai'\nimport { make, pipe, toObservable } from 'wonka'\nimport { queryClientAtom } from './queryClientAtom'\nimport { shouldThrowError } from './utils'\n\nexport function atomWithMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => MutationObserverOptions<TData, TError, TVariables, TContext>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n) {\n  const IN_RENDER = Symbol()\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    return client.defaultMutationOptions(options)\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        MutationObserver<TData, TError, TVariables, TContext>\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n    const observerCache = get(observerCacheAtom)\n\n    const observer = observerCache.get(client)\n\n    if (observer) {\n      ;(observer as any)[IN_RENDER] = true\n      observer.setOptions(options)\n      delete (observer as any)[IN_RENDER]\n\n      return observer\n    }\n\n    const newObserver = new MutationObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  const observableAtom = atom((get) => {\n    const observer = get(observerAtom)\n    const source = make<\n      MutationObserverResult<TData, TError, TVariables, TContext>\n    >(({ next }) => {\n      const callback = (\n        result: MutationObserverResult<TData, TError, TVariables, TContext>\n      ) => {\n        const notifyResult = () => next(result)\n\n        if ((observer as any)[IN_RENDER]) {\n          Promise.resolve().then(notifyResult)\n        } else {\n          notifyResult()\n        }\n      }\n\n      return observer.subscribe(callback)\n    })\n    return pipe(source, toObservable)\n  })\n\n  const dataAtom = atom((get) => {\n    const observer = get(observerAtom)\n    const observable = get(observableAtom)\n\n    const currentResult = observer.getCurrentResult()\n    const resultAtom = atom(currentResult)\n\n    resultAtom.onMount = (set) => {\n      const { unsubscribe } = observable.subscribe((state) => {\n        set(state)\n      })\n      return () => {\n        unsubscribe\n        observer.reset()\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  const mutateAtom = atom((get) => {\n    const observer = get(observerAtom)\n    const mutate = (\n      variables: TVariables,\n      options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n    ) => {\n      observer.mutate(variables, options).catch(noop)\n    }\n\n    return mutate\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    mutateAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    const observer = get(observerAtom)\n    const resultAtom = get(dataAtom)\n\n    const result = get(resultAtom)\n    const mutate = get(mutateAtom)\n\n    if (\n      result.isError &&\n      shouldThrowError(observer.options.throwOnError, [result.error])\n    ) {\n      throw result.error\n    }\n\n    return { ...result, mutate, mutateAsync: result.mutate }\n  })\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import { InfiniteQueryObserver, QueryClient } from '@tanstack/query-core'\nimport type {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  WithRequired,\n} from '@tanstack/query-core'\nimport { Atom, type Getter, atom } from 'jotai/vanilla'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport function atomWithInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => InfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<InfiniteQueryObserverResult<TData, TError>> {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        InfiniteQueryObserver<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryFnData,\n          TQueryKey,\n          TPageParam\n        >\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(\n      options\n    ) as DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new InfiniteQueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n\n  return baseAtomWithQuery<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >(\n    (get) => ({\n      ...get(optionsAtom),\n      suspense: false,\n    }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n\ninterface InfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends WithRequired<\n    Omit<\n      InfiniteQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey,\n        TPageParam\n      >,\n      'suspense'\n    >,\n    'queryKey'\n  > {}\n","import {\n  DefaultError,\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\nimport { Getter, atom } from 'jotai'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>\n): Array<TResult> {\n  return mutationCache\n    .findAll({ ...options.filters, status: 'pending' })\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>\n            )\n          : mutation.state) as TResult\n    )\n}\n\nexport const atomWithMutationState = <TResult = MutationState>(\n  getOptions: (get: Getter) => MutationStateOptions<TResult>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n) => {\n  const resultsAtom = atom<TResult[]>([])\n  if (process.env.NODE_ENV !== 'production') {\n    resultsAtom.debugPrivate = true\n  }\n\n  const observableAtom = atom((get) => {\n    const queryClient = getQueryClient(get)\n\n    const mutationCache = queryClient.getMutationCache()\n    resultsAtom.onMount = (set) => {\n      mutationCache.subscribe(() => {\n        set(getResult(getQueryClient(get).getMutationCache(), getOptions(get)))\n      })\n    }\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observableAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    get(observableAtom)\n    return get(resultsAtom)\n  })\n}\n","import {\n  DefaultError,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport function atomWithQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => Omit<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n    'suspense'\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<QueryObserverResult<TData, TError>> {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(options)\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new QueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  return baseAtomWithQuery<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n    (get) => ({ ...get(optionsAtom), suspense: false }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n","import {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  InfiniteData,\n  InfiniteQueryObserver,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverSuccessResult,\n  QueryClient,\n  type QueryKey,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport const atomWithSuspenseInfiniteQuery = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  getOptions: (\n    get: Getter\n  ) => SuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TPageParam,\n    TData,\n    TQueryKey\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<Promise<InfiniteQueryObserverSuccessResult<TData, TError>>> => {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        InfiniteQueryObserver<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryFnData,\n          TQueryKey,\n          TPageParam\n        >\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(\n      options\n    ) as DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (typeof dOptions.staleTime !== 'number') {\n      dOptions.staleTime = 1000\n    }\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new InfiniteQueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  return baseAtomWithQuery<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >(\n    (get) => ({\n      ...get(optionsAtom),\n      suspense: true,\n      enabled: true,\n    }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n\ninterface SuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TPageParam = unknown,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Omit<\n    InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n    'enabled' | 'throwOnError' | 'placeholderData'\n  > {}\n","import {\n  DefaultError,\n  type DefinedQueryObserverResult,\n  QueryClient,\n  type QueryKey,\n  QueryObserver,\n  type QueryObserverOptions,\n} from '@tanstack/query-core'\nimport { Atom, Getter, atom } from 'jotai'\nimport { baseAtomWithQuery } from './baseAtomWithQuery'\nimport { queryClientAtom } from './queryClientAtom'\n\nexport const atomWithSuspenseQuery = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  getOptions: (\n    get: Getter\n  ) => Omit<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n    'suspense' | 'enabled'\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): Atom<\n  | DefinedQueryObserverResult<TData, TError>\n  | Promise<DefinedQueryObserverResult<TData, TError>>\n> => {\n  const observerCacheAtom = atom(\n    () =>\n      new WeakMap<\n        QueryClient,\n        QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      >()\n  )\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const optionsAtom = atom((get) => {\n    const client = getQueryClient(get)\n    const options = getOptions(get)\n    const cache = get(observerCacheAtom)\n    const cachedObserver = cache.get(client)\n    const dOptions = client.defaultQueryOptions(options)\n\n    dOptions._optimisticResults = 'optimistic'\n\n    if (typeof dOptions.staleTime !== 'number') {\n      dOptions.staleTime = 1000\n    }\n\n    if (cachedObserver) {\n      cachedObserver.setOptions(dOptions, { listeners: false })\n    }\n\n    return dOptions\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    optionsAtom.debugPrivate = true\n  }\n\n  const observerAtom = atom((get) => {\n    const options = get(optionsAtom)\n    const client = getQueryClient(get)\n\n    const observerCache = get(observerCacheAtom)\n\n    const cachedObserver = observerCache.get(client)\n\n    if (cachedObserver) return cachedObserver\n\n    const newObserver = new QueryObserver(client, options)\n    observerCache.set(client, newObserver)\n\n    return newObserver\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  return baseAtomWithQuery<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n    (get) => ({\n      ...get(optionsAtom),\n      suspense: true,\n      enabled: true,\n    }),\n    (get) => get(observerAtom),\n    getQueryClient\n  )\n}\n"],"names":["queryClientAtom","atom","QueryClient","shouldThrowError","throwOnError","params","apply","baseAtomWithQuery","getOptions","getObserver","getQueryClient","get","resetAtom","process","env","NODE_ENV","debugPrivate","observableAtom","observer","source","make","_ref","next","subscribe","result","pipe","toObservable","dataAtom","observable","currentResult","getCurrentResult","resultAtom","onMount","set","unsubscribe","state","options","client","isError","resetQueries","queryKey","getCurrentQuery","getOptimisticResult","defaultedOptions","isRestoring","suspense","isPending","willFetch","shouldSuspend","fetchOptimistic","isFetching","error","query","getHasError","noop","observerCacheAtom","WeakMap","optionsAtom","cachedObserver","dOptions","defaultQueryOptions","_optimisticResults","setOptions","listeners","observerAtom","observerCache","newObserver","InfiniteQueryObserver","_extends","IN_RENDER","Symbol","defaultMutationOptions","MutationObserver","notifyResult","Promise","resolve","then","reset","mutateAtom","variables","mutate","mutateAsync","resultsAtom","mutationCache","getMutationCache","findAll","filters","status","map","mutation","select","getResult","QueryObserver","staleTime","enabled"],"mappings":"4aAGaA,IAAAA,EAAkBC,EAAIA,KAAC,IAAIC,EAAaA,iPC0CrC,SAAAC,EACdC,EACAC,GAGA,MAA4B,mBAAjBD,EACFA,EAAYE,WAAID,EAAAA,KAGhBD,CACX,UCiEgBG,EAOdC,EASAC,EAGAC,QAAAA,IAAAA,IAAAA,EAA+C,SAACC,GAAG,OAAKA,EAAIX,EAAgB,GAE5E,IAAMY,EAAYX,EAAAA,KAAK,GACM,eAAzBY,QAAQC,IAAIC,WACdH,EAAUI,cAAe,GAG3B,IAAMC,EAAiBhB,EAAIA,KAAC,SAACU,GAC3B,IAAMO,EAAWT,EAAYE,GACvBQ,EAASC,EAAAA,KAAyC,SAAAC,GAAG,IAAAC,EAAID,EAAJC,KAKzD,OAAOJ,EAASK,UAJC,SAACC,GAChBF,EAAKE,EACP,EAGF,GACA,OAAOC,OAAKN,EAAQO,EAAYA,aAClC,GAC6B,eAAzBb,QAAQC,IAAIC,WACdE,EAAeD,cAAe,GAGhC,IAAMW,EAAW1B,OAAK,SAACU,GACrB,IAAMO,EAAWT,EAAYE,GACvBiB,EAAajB,EAAIM,GAEjBY,EAAgBX,EAASY,mBACzBC,EAAa9B,EAAIA,KAAC4B,GAYxB,MAX6B,eAAzBhB,QAAQC,IAAIC,WACdgB,EAAWf,cAAe,GAG5Be,EAAWC,QAAU,SAACC,GACpB,IAAQC,EAAgBN,EAAWL,UAAU,SAACY,GAC5CF,EAAIE,EACN,GAFQD,YAGR,OAAa,WAAA,OAAAA,GAAa,CAC5B,EAEOH,CACT,GAKA,MAJ6B,eAAzBlB,QAAQC,IAAIC,WACdY,EAASX,cAAe,GAGnBf,OAAK,SAACU,GACX,IAAMO,EAAWT,EAAYE,GACvByB,EAAU5B,EAAWG,GAErB0B,EAAS3B,EAAeC,GAE9BC,EAAUoB,QAAU,WAClB,kBACMd,EAASY,mBAAmBQ,SAC9BD,EAAOE,aAAa,CAAEC,SAAUtB,EAASuB,kBAAkBD,UAE/D,CACF,EAEA7B,EAAIC,GACJD,EAAIA,EAAIgB,IAER,IAAMH,EAASN,EAASwB,oBAAoBN,GAE5C,GDnMyB,SAC3BO,EAGAnB,EACAoB,GACG,OAAgB,MAAhBD,OAAgB,EAAhBA,EAAkBE,WAEE,SACvBrB,EACAoB,GACG,OAAApB,EAAOsB,YAAa,CAAY,CALFC,CAAUvB,EAAoB,CC6LzDwB,CAAcZ,EAASZ,GACzB,OAAON,EAAS+B,gBAAgBb,GAGlC,GD1LuB,SAAHf,GAOtB,IAAAG,EAAMH,EAANG,OAUA,OACEA,EAAOc,UACNd,EAAO0B,YACR/C,EAZUkB,EAAZjB,aAYiC,CAACoB,EAAO2B,MAXpC9B,EAAL+B,OAaF,CCqKMC,CAAY,CACV7B,OAAAA,EACA4B,MAAOlC,EAASuB,kBAChBrC,aAAcgC,EAAQhC,eAGxB,MAAMoB,EAAO2B,MAGf,OAAO3B,CACT,EACF,CCxEA,SAAS8B,KH9IoB,eAAzBzC,QAAQC,IAAIC,WACdf,EAAgBgB,cAAe,2BIQjB,SAOdR,EAGAE,QAA+C,IAA/CA,IAAAA,EAA+C,SAACC,GAAQ,OAAAA,EAAIX,EAAgB,GAE5E,IAAMuD,EAAoBtD,EAAAA,KACxB,kBACM,IAAAuD,OAUD,GAEsB,eAAzB3C,QAAQC,IAAIC,WACdwC,EAAkBvC,cAAe,GAEnC,IAAMyC,EAAcxD,EAAAA,KAAK,SAACU,GACxB,IAAM0B,EAAS3B,EAAeC,GACxByB,EAAU5B,EAAWG,GAErB+C,EADQ/C,EAAI4C,GACW5C,IAAI0B,GAC3BsB,EAAWtB,EAAOuB,oBACtBxB,GAgBF,OANAuB,EAASE,mBAAqB,aAE1BH,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,CACT,GAC6B,eAAzB9C,QAAQC,IAAIC,WACd0C,EAAYzC,cAAe,GAE7B,IAAMgD,EAAe/D,EAAAA,KAAK,SAACU,GACzB,IAAMyB,EAAUzB,EAAI8C,GACdpB,EAAS3B,EAAeC,GAExBsD,EAAgBtD,EAAI4C,GAEpBG,EAAiBO,EAActD,IAAI0B,GACzC,GAAIqB,EAAgB,OAAOA,EAE3B,IAAMQ,EAAc,IAAIC,EAAqBA,sBAAC9B,EAAQD,GAGtD,OAFA6B,EAAchC,IAAII,EAAQ6B,GAEnBA,CACT,GAEA,OAAO3D,EAQL,SAACI,GAAG,OAAAyD,EAAA,CAAA,EACCzD,EAAI8C,GAAY,CACnBZ,UAAU,GAAK,EAEjB,SAAClC,GAAQ,OAAAA,EAAIqD,EAAa,EAC1BtD,EAEJ,qBDzFgB,SAMdF,EAGAE,QAA+C,IAA/CA,IAAAA,EAA+C,SAACC,UAAQA,EAAIX,EAAgB,GAE5E,IAAMqE,EAAYC,SAEZb,EAAcxD,EAAIA,KAAC,SAACU,GACxB,IAAM0B,EAAS3B,EAAeC,GACxByB,EAAU5B,EAAWG,GAC3B,OAAO0B,EAAOkC,uBAAuBnC,EACvC,GAC6B,eAAzBvB,QAAQC,IAAIC,WACd0C,EAAYzC,cAAe,GAG7B,IAAMuC,EAAoBtD,EAAAA,KACxB,WAAA,WACMuD,OAGD,GAEsB,eAAzB3C,QAAQC,IAAIC,WACdwC,EAAkBvC,cAAe,GAGnC,IAAMgD,EAAe/D,EAAAA,KAAK,SAACU,GACzB,IAAMyB,EAAUzB,EAAI8C,GACdpB,EAAS3B,EAAeC,GACxBsD,EAAgBtD,EAAI4C,GAEpBrC,EAAW+C,EAActD,IAAI0B,GAEnC,GAAInB,EAKF,OAJEA,EAAiBmD,IAAa,EAChCnD,EAAS4C,WAAW1B,UACZlB,EAAiBmD,GAElBnD,EAGT,IAAMgD,EAAc,IAAIM,EAAgBA,iBAACnC,EAAQD,GAGjD,OAFA6B,EAAchC,IAAII,EAAQ6B,GAEnBA,CACT,GAC6B,eAAzBrD,QAAQC,IAAIC,WACdiD,EAAahD,cAAe,GAG9B,IAAMC,EAAiBhB,OAAK,SAACU,GAC3B,IAAMO,EAAWP,EAAIqD,GACf7C,EAASC,EAAAA,KAEb,SAAAC,GAAa,IAAVC,EAAID,EAAJC,KAaH,OAAOJ,EAASK,UAZC,SACfC,GAEA,IAAMiD,EAAe,WAAM,OAAAnD,EAAKE,EAAO,EAElCN,EAAiBmD,GACpBK,QAAQC,UAAUC,KAAKH,GAEvBA,GAEJ,EAGF,GACA,OAAOhD,EAAAA,KAAKN,EAAQO,EAAYA,aAClC,GAEMC,EAAW1B,OAAK,SAACU,GACrB,IAAMO,EAAWP,EAAIqD,GACfpC,EAAajB,EAAIM,GAEjBY,EAAgBX,EAASY,mBACzBC,EAAa9B,EAAAA,KAAK4B,GAexB,OAbAE,EAAWC,QAAU,SAACC,GAIpB,OAHwBL,EAAWL,UAAU,SAACY,GAC5CF,EAAIE,EACN,cAGEjB,EAAS2D,OACX,CACF,EAC6B,eAAzBhE,QAAQC,IAAIC,WACdgB,EAAWf,cAAe,GAGrBe,CACT,GAEM+C,EAAa7E,OAAK,SAACU,GACvB,IAAMO,EAAWP,EAAIqD,GAQrB,OAPe,SACbe,EACA3C,GAEAlB,EAAS8D,OAAOD,EAAW3C,GAAQ,MAAOkB,EAC5C,CAGF,GAKA,MAJ6B,eAAzBzC,QAAQC,IAAIC,WACd+D,EAAW9D,cAAe,GAGrBf,EAAAA,KAAK,SAACU,GACX,IAAMO,EAAWP,EAAIqD,GACfjC,EAAapB,EAAIgB,GAEjBH,EAASb,EAAIoB,GACbiD,EAASrE,EAAImE,GAEnB,GACEtD,EAAOc,SACPnC,EAAiBe,EAASkB,QAAQhC,aAAc,CAACoB,EAAO2B,QAExD,MAAM3B,EAAO2B,MAGf,OAAAiB,EAAY5C,CAAAA,EAAAA,EAAQwD,CAAAA,OAAAA,EAAQC,YAAazD,EAAOwD,QAClD,EACF,0BE9GqC,SACnCxE,EACAE,QAAAA,IAAAA,IAAAA,EAA+C,SAACC,UAAQA,EAAIX,EAAgB,GAE5E,IAAMkF,EAAcjF,EAAAA,KAAgB,IACP,eAAzBY,QAAQC,IAAIC,WACdmE,EAAYlE,cAAe,GAG7B,IAAMC,EAAiBhB,EAAIA,KAAC,SAACU,GAC3B,IAEMwE,EAFczE,EAAeC,GAEDyE,mBAClCF,EAAYlD,QAAU,SAACC,GACrBkD,EAAc5D,UAAU,WACtBU,EA/BR,SACEkD,EACA/C,GAEA,OAAO+C,EACJE,QAAOjB,KAAMhC,EAAQkD,QAAO,CAAEC,OAAQ,aACtCC,IACC,SAACC,GACE,OAAArD,EAAQsD,OACLtD,EAAQsD,OACND,GAEFA,EAAStD,KAAK,EAE1B,CAiBYwD,CAAUjF,EAAeC,GAAKyE,mBAAoB5E,EAAWG,IACnE,EACF,CACF,GAKA,MAJ6B,eAAzBE,QAAQC,IAAIC,WACdE,EAAeD,cAAe,GAGzBf,EAAAA,KAAK,SAACU,GAEX,OADAA,EAAIM,GACGN,EAAIuE,EACb,EACF,kBCjDgB,SAOd1E,EAMAE,QAA+C,IAA/CA,IAAAA,EAA+C,SAACC,GAAQ,OAAAA,EAAIX,EAAgB,GAE5E,IAAMuD,EAAoBtD,EAAAA,KACxB,WAAA,OACM,IAAAuD,OAGD,GAEsB,eAAzB3C,QAAQC,IAAIC,WACdwC,EAAkBvC,cAAe,GAGnC,IAAMyC,EAAcxD,EAAAA,KAAK,SAACU,GACxB,IAAM0B,EAAS3B,EAAeC,GACxByB,EAAU5B,EAAWG,GAErB+C,EADQ/C,EAAI4C,GACW5C,IAAI0B,GAC3BsB,EAAWtB,EAAOuB,oBAAoBxB,GAQ5C,OANAuB,EAASE,mBAAqB,aAE1BH,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,CACT,GAC6B,eAAzB9C,QAAQC,IAAIC,WACd0C,EAAYzC,cAAe,GAG7B,IAAMgD,EAAe/D,EAAIA,KAAC,SAACU,GACzB,IAAMyB,EAAUzB,EAAI8C,GACdpB,EAAS3B,EAAeC,GAExBsD,EAAgBtD,EAAI4C,GAEpBG,EAAiBO,EAActD,IAAI0B,GAEzC,GAAIqB,EAAgB,OAAOA,EAE3B,IAAMQ,EAAc,IAAI0B,EAAAA,cAAcvD,EAAQD,GAG9C,OAFA6B,EAAchC,IAAII,EAAQ6B,GAEnBA,CACT,GAKA,MAJ6B,eAAzBrD,QAAQC,IAAIC,WACdiD,EAAahD,cAAe,GAGvBT,EACL,SAACI,GAAGyD,OAAAA,KAAWzD,EAAI8C,IAAcZ,UAAU,GAAK,EAChD,SAAClC,GAAQ,OAAAA,EAAIqD,EAAa,EAC1BtD,EAEJ,kCCnE6C,SAO3CF,EASAE,QAAAA,IAAAA,IAAAA,EAA+C,SAACC,GAAG,OAAKA,EAAIX,EAAgB,GAE5E,IAAMuD,EAAoBtD,EAAAA,KACxB,WAAA,WACMuD,OAUD,GAEsB,eAAzB3C,QAAQC,IAAIC,WACdwC,EAAkBvC,cAAe,GAGnC,IAAMyC,EAAcxD,EAAAA,KAAK,SAACU,GACxB,IAAM0B,EAAS3B,EAAeC,GACxByB,EAAU5B,EAAWG,GAErB+C,EADQ/C,EAAI4C,GACW5C,IAAI0B,GAC3BsB,EAAWtB,EAAOuB,oBACtBxB,GAoBF,OAVAuB,EAASE,mBAAqB,aAEI,iBAAvBF,EAASkC,YAClBlC,EAASkC,UAAY,KAGnBnC,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,CACT,GAC6B,eAAzB9C,QAAQC,IAAIC,WACd0C,EAAYzC,cAAe,GAG7B,IAAMgD,EAAe/D,EAAAA,KAAK,SAACU,GACzB,IAAMyB,EAAUzB,EAAI8C,GACdpB,EAAS3B,EAAeC,GAExBsD,EAAgBtD,EAAI4C,GAEpBG,EAAiBO,EAActD,IAAI0B,GAEzC,GAAIqB,EAAgB,OAAOA,EAE3B,IAAMQ,EAAc,IAAIC,wBAAsB9B,EAAQD,GAGtD,OAFA6B,EAAchC,IAAII,EAAQ6B,GAEnBA,CACT,GAKA,MAJ6B,eAAzBrD,QAAQC,IAAIC,WACdiD,EAAahD,cAAe,GAGvBT,EAQL,SAACI,UAAGyD,EAAA,GACCzD,EAAI8C,GACPZ,CAAAA,UAAU,EACViD,SAAS,GAAI,EAEf,SAACnF,GAAQ,OAAAA,EAAIqD,EAAa,EAC1BtD,EAEJ,0BCzGqC,SAOnCF,EAMAE,QAAAA,IAAAA,IAAAA,EAA+C,SAACC,GAAG,OAAKA,EAAIX,EAAgB,GAK5E,IAAMuD,EAAoBtD,EAAAA,KACxB,WAAA,WACMuD,OAGD,GAEsB,eAAzB3C,QAAQC,IAAIC,WACdwC,EAAkBvC,cAAe,GAGnC,IAAMyC,EAAcxD,EAAAA,KAAK,SAACU,GACxB,IAAM0B,EAAS3B,EAAeC,GACxByB,EAAU5B,EAAWG,GAErB+C,EADQ/C,EAAI4C,GACW5C,IAAI0B,GAC3BsB,EAAWtB,EAAOuB,oBAAoBxB,GAY5C,OAVAuB,EAASE,mBAAqB,aAEI,iBAAvBF,EAASkC,YAClBlC,EAASkC,UAAY,KAGnBnC,GACFA,EAAeI,WAAWH,EAAU,CAAEI,WAAW,IAG5CJ,CACT,GAC6B,eAAzB9C,QAAQC,IAAIC,WACd0C,EAAYzC,cAAe,GAG7B,IAAMgD,EAAe/D,EAAAA,KAAK,SAACU,GACzB,IAAMyB,EAAUzB,EAAI8C,GACdpB,EAAS3B,EAAeC,GAExBsD,EAAgBtD,EAAI4C,GAEpBG,EAAiBO,EAActD,IAAI0B,GAEzC,GAAIqB,EAAgB,OAAOA,EAE3B,IAAMQ,EAAc,IAAI0B,gBAAcvD,EAAQD,GAG9C,OAFA6B,EAAchC,IAAII,EAAQ6B,GAEnBA,CACT,GAKA,MAJ6B,eAAzBrD,QAAQC,IAAIC,WACdiD,EAAahD,cAAe,GAGvBT,EACL,SAACI,UAAGyD,EAAA,GACCzD,EAAI8C,GACPZ,CAAAA,UAAU,EACViD,SAAS,GAAI,EAEf,SAACnF,GAAQ,OAAAA,EAAIqD,EAAa,EAC1BtD,EAEJ"}