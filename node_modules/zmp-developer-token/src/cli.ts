#!/usr/bin/env node

import { execSync } from "child_process";
import { ProxyAgent } from "proxy-agent";
import { renewAccessToken } from "./index";

// To be used as CLI
async function main() {
  const command = process.argv[2];
  switch (command) {
    case "deploy":
      let [MINI_APP_ID, ACCESS_TOKEN] = process.argv.slice(3);
      execSync(
        `printf "\\033[B\n${ACCESS_TOKEN ? ACCESS_TOKEN : "$NEW_ACCESS_TOKEN"
        }" | APP_ID=${MINI_APP_ID} zmp login`
      );
      execSync('printf "\\033[B\n`git log -1 --pretty=%B`" | zmp deploy');
      break;

    case "login":
      let [APP_ID, APP_SECRET, REFRESH_TOKEN] = process.argv.slice(3);
      if (!APP_ID || !APP_SECRET || !REFRESH_TOKEN) {
        throw new Error(
          "Please put ZALO_APP_ID, ZALO_APP_SECRET, ZALO_REFRESH_TOKEN inside environment variables. If you are using Github Actions, put it inside Secrets!"
        );
      }
      const nodeFetch = (await import("node-fetch")).default;
      const fetcher = (url: string, options) => {
        return nodeFetch(url, {
          ...options,
          agent: new ProxyAgent(),
        });
      }
      const { error, error_description, access_token, refresh_token } =
        await renewAccessToken(
          APP_ID,
          APP_SECRET,
          REFRESH_TOKEN,
          fetcher as unknown as typeof fetch
        );
      if (error) {
        throw new Error(error_description);
      } else {
        // Pass these env into the next jobs. If you're using Github Actions, it would look like this >> $GITHUB_ENV
        // Please don't change APP_ID & ZMP_TOKEN, otherwise zmp-cli won't collect it
        // Save this refresh token back, the old refresh token is now invalid
        console.log(
          [
            `NEW_ACCESS_TOKEN=${access_token}`,
            `NEW_REFRESH_TOKEN=${refresh_token}`,
          ].join("\n")
        );
      }
      break;

    default:
      throw new Error("Operation not supported!");
  }
}

main();
